# -*- makefile -*-
# 
# This file describes which puzzle binaries are made up from which
# object and resource files. It is processed into the various
# Makefiles by means of a Perl script. Makefile changes should
# really be made by editing this file and/or the Perl script, not
# by editing the actual Makefiles.

!name puzzles

!makefile gtk Makefile
!makefile vc Makefile.vc
!makefile wce Makefile.wce
!makefile cygwin Makefile.cyg
!makefile osx Makefile.osx
!makefile gnustep Makefile.gnustep
!makefile nestedvm Makefile.nestedvm
!makefile emcc Makefile.emcc

!srcdir icons/

WINDOWS_COMMON = printing
         + user32.lib gdi32.lib comctl32.lib comdlg32.lib winspool.lib
WINDOWS  = windows WINDOWS_COMMON
COMMON   = midend drawing misc malloc random version
GTK      = gtk printing ps
# Objects needed for auxiliary command-line programs.
STANDALONE = nullfe random misc malloc

ALL      = list

# First half of list.c.
!begin >list.c
/*
 * list.c: List of pointers to puzzle structures, for monolithic
 * platforms.
 *
 * This file is automatically generated by mkfiles.pl. Do not edit
 * it directly, or the changes will be lost next time mkfiles.pl runs.
 * Instead, edit Recipe and/or its *.R subfiles.
 */
#include "puzzles.h"
#define GAMELIST(A) \
!end

# Now each .R file adds part of the macro definition of GAMELIST to list.c.
!include *.R

# Then we finish up list.c as follows:
!begin >list.c

#define DECL(x) extern const game x;
#define REF(x) &x,
GAMELIST(DECL)
const game *gamelist[] = { GAMELIST(REF) };
const int gamecount = lenof(gamelist);
!end

# Unix standalone application for special-purpose obfuscation.
obfusc : [U] obfusc STANDALONE

puzzles  : [G] windows[COMBINED] WINDOWS_COMMON COMMON ALL noicon.res

# Mac OS X unified application containing all the puzzles.
Puzzles  : [MX] osx osx.icns osx-info.plist COMMON ALL
# For OS X, we must create the online help and include it in the
# application bundle.) Also we add -DCOMBINED to the compiler flags
# so as to inform the code that we're building a single binary for
# all the puzzles. Then I've also got some code in here to build a
# distributable .dmg disk image.
!begin osx
Puzzles_extra = Puzzles.app/Contents/Resources/Help/index.html
Puzzles.app/Contents/Resources/Help/index.html: \
	Puzzles.app/Contents/Resources/Help osx-help.but puzzles.but
	cd Puzzles.app/Contents/Resources/Help; \
		halibut --html ../../../../osx-help.but ../../../../puzzles.but
Puzzles.app/Contents/Resources/Help: Puzzles.app/Contents/Resources
	mkdir -p Puzzles.app/Contents/Resources/Help

release: Puzzles.dmg
Puzzles.dmg: Puzzles
	rm -f raw.dmg
	hdiutil create -megabytes 5 -layout NONE raw.dmg
	hdid -nomount raw.dmg > devicename
	newfs_hfs -v "Simon Tatham's Puzzle Collection" `cat devicename`
	hdiutil eject `cat devicename`
	hdid raw.dmg | cut -f1 -d' ' > devicename
	cp -R Puzzles.app /Volumes/"Simon Tatham's Puzzle Collection"
	hdiutil eject `cat devicename`
	rm -f Puzzles.dmg
	hdiutil convert -format UDCO raw.dmg -o Puzzles.dmg
	rm -f raw.dmg devicename
!end

# Version management.
!begin vc
version.obj: *.c *.h
	cl $(VER) $(CFLAGS) /c version.c
!end
!specialobj vc version
!begin wce
version.obj: *.c *.h
	$(CC) $(VER) $(CFLAGS) /c version.c
!end
!specialobj wce version
!begin cygwin
version.o: FORCE;
FORCE:
	$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) $(VER) -c version.c
!end
!specialobj cygwin version
# For Unix, we also need the gross MD5 hack that causes automatic
# version number selection in release source archives.
!begin gtk
version.o: version.c version2.def
	$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version2.def` -c version.c
version2.def: FORCE
	if test -z "$(VER)" && test -f manifest && md5sum -c manifest; then \
		cat version.def > version2.def.new; \
	elif test -z "$(VER)" && test -d .svn && svnversion . >/dev/null 2>&1; then \
		echo "-DREVISION=`svnversion .`" >version2.def.new; \
	else \
		echo "$(VER)" >version2.def.new; \
	fi && \
	if diff -q version2.def.new version2.def; then \
		rm version2.def.new; \
	else \
		mv version2.def.new version2.def; \
	fi
.PHONY: FORCE
!end
!specialobj gtk version
!begin nestedvm
version.o: version.c version2.def
	$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version2.def` -c version.c
version2.def: FORCE
	if test -z "$(VER)" && test -f manifest && md5sum -c manifest; then \
		cat version.def > version2.def.new; \
	elif test -z "$(VER)" && test -d .svn && svnversion . >/dev/null 2>&1; then \
		echo "-DREVISION=`svnversion .`" >version2.def.new; \
	else \
		echo "$(VER)" >version2.def.new; \
	fi && \
	if diff -q version2.def.new version2.def; then \
		rm version2.def.new; \
	else \
		mv version2.def.new version2.def; \
	fi
.PHONY: FORCE
!end
!specialobj nestedvm version
# For OS X, this is made more fiddly by the fact that we don't have
# md5sum readily available. We do, however, have `md5 -r' which
# generates _nearly_ the same output, but it has no check function.
!begin osx
version.ppc.o: version.c version2.def
	$(CC) -arch ppc $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version2.def` -c version.c -o $@
version.i386.o: version.c version2.def
	$(CC) -arch i386 $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version2.def` -c version.c -o $@
version2.def: FORCE
	if test -z "$(VER)" && test -f manifest && (md5 -r `awk '{print $$2}' manifest` | diff -w manifest -); then \
		cat version.def > version2.def.new; \
	elif test -z "$(VER)" && test -d .svn && svnversion . >/dev/null 2>&1; then \
		echo "-DREVISION=`svnversion .`" >version2.def.new; \
	else \
		echo "$(VER)" >version2.def.new; \
	fi && \
	if diff -q version2.def.new version2.def; then \
		rm version2.def.new; \
	else \
		mv version2.def.new version2.def; \
	fi
.PHONY: FORCE
!end
!specialobj osx version

# make install for Unix.
!begin gtk
install:
	for i in $(GAMES); do \
		$(INSTALL_PROGRAM) -m 755 $(BINPREFIX)$$i $(DESTDIR)$(gamesdir)/$(BINPREFIX)$$i \
		|| exit 1; \
	done
!end
!begin nestedvm
.PRECIOUS: %.class
%.class: %.mips
	java -cp $(NESTEDVM)/build:$(NESTEDVM)/upstream/build/classgen/build \
		org.ibex.nestedvm.Compiler -outformat class -d . \
		PuzzleEngine $<
		mv PuzzleEngine.class $@

org:
	mkdir -p org/ibex/nestedvm/util
	cp $(NESTEDVM)/build/org/ibex/nestedvm/{Registers,UsermodeConstants,Runtime*}.class org/ibex/nestedvm
	cp $(NESTEDVM)/build/org/ibex/nestedvm/util/{Platform*,Seekable*}.class org/ibex/nestedvm/util
	echo "Main-Class: PuzzleApplet" >applet.manifest

PuzzleApplet.class: PuzzleApplet.java org
	javac -source 1.3 -target 1.3 PuzzleApplet.java

%.jar: %.class PuzzleApplet.class org
	mv $< PuzzleEngine.class
	jar cfm $@ applet.manifest PuzzleEngine.class PuzzleApplet*.class org
	echo '<applet archive="'$@'" code="PuzzleApplet" width="700" height="500"></applet>' >$*.html
	mv PuzzleEngine.class $<
!end
